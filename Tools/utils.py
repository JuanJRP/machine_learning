# -*- coding: utf-8 -*-
"""Funtion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JGRV6wrWAu3MqIp5IhGShBbDVARCnAgh
"""

__all__ = ["plot_decision_boundary"]

import numpy as np
import matplotlib.pyplot as plt

def plot_decision_boundary(model, X, y, n_classes, ax, grid_size=(100, 100)):
    """
    Plots the decision boundary of a given classification model.

    Parameters:
    - model: The trained classification model with a `predict` method.
    - X (numpy.ndarray): Feature matrix of shape (n_samples, 2), where each row represents a data point.
    - y (numpy.ndarray): Target labels corresponding to X.
    - n_classes (int): The number of distinct classes in the dataset.
    - ax (matplotlib.axes.Axes): The Matplotlib Axes object where the decision boundary will be plotted.
    - grid_size (tuple, optional): The resolution of the decision boundary grid,
      given as (grid_size_x, grid_size_y). Default is (100, 100).

    Behavior:
    - Creates a mesh grid over the feature space.
    - Predicts class labels for each point in the grid using the given model.
    - Colors the decision regions according to the modelâ€™s predictions.
    - Plots the original data points on top of the decision boundary.

    Example usage:
    ```python
    fig, ax = plt.subplots()
    plot_decision_boundary(trained_model, X, y, n_classes=3, ax=ax)
    plt.show()
    ```

    Note:
    - The function assumes the model's `predict` method returns class labels.
    - Works only for 2D feature spaces (X must have exactly two features).
    """

    # Extract grid size values
    grid_size_x, grid_size_y = grid_size
    offset = 0.2  # Margin around the data points

    # Determine the min and max for both features with some offset
    x_min, x_max = min(X[:, 0]) - offset, max(X[:, 0]) + offset
    y_min, y_max = min(X[:, 1]) - offset, max(X[:, 1]) + offset

    # Create a grid of points covering the feature space
    x_grid, y_grid = np.meshgrid(np.linspace(x_min, x_max, grid_size_x),
                                 np.linspace(y_min, y_max, grid_size_y))

    # Predict class labels for each point in the grid
    pred_grid = model.predict(np.c_[x_grid.ravel(), y_grid.ravel()])
    pred_grid = pred_grid.reshape(x_grid.shape)

    # Plot the decision boundary by coloring the grid with predictions
    cmap = plt.cm.get_cmap("Paired", n_classes)
    ax.pcolormesh(x_grid, y_grid, pred_grid, cmap=cmap)

    # Scatter plot the data points on top of the decision boundary
    scatter = ax.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k', cmap="Set1")

    # Remove axis ticks for better visualization
    ax.set_xticks(())
    ax.set_yticks(())

    # Add title with model name
    ax.set_title(f'{model.__class__.__name__}')

